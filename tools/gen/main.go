package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path"
	"reflect"
	"strings"
)

var typeMap = map[string]bool{
	"byte":   true,
	"bool":   true,
	"int8":   true,
	"int16":  true,
	"int32":  true,
	"int64":  true,
	"uint8":  true,
	"uint16": true,
	"uint32": true,
	"uint64": true,
	"string": true,
}

var (
	input  string
	output string
)

var (
	protoPrefix string
)

func main() {
	flag.StringVar(&input, "input", "", "input file")
	flag.StringVar(&output, "output", "", "output file")
	flag.Parse()

	if _, err := ioutil.ReadFile(input); err != nil {
		log.Fatal(err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, input, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	var b strings.Builder

	// package
	b.WriteString("// Code generated by speedfs-gen. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", f.Name))

	if path.Dir(input) != "proto" {
		b.WriteString("import (\n\t\"github.com/speedfs/speedfs/proto\"\n)\n\n")
		protoPrefix = "proto."
	}

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if !token.IsExported(typeSpec.Name.Name) {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// ast.Print(fset, spec)
			generateEncodeTo(typeSpec, structType, &b)
			generateDecodeFrom(typeSpec, structType, &b)
		}
	}

	buf, err := format.Source([]byte(b.String()))
	if err != nil {
		fmt.Println(b.String())
		log.Fatal(err)
	}

	w, err := os.OpenFile(output, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0755)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := w.Write(buf); err != nil {
		log.Fatal(err)
	}
}

func generateEncodeTo(typeSpec *ast.TypeSpec, structType *ast.StructType, b *strings.Builder) {
	b.WriteString("// EncodeTo\n")
	typeName := typeSpec.Name.Name
	b.WriteString(fmt.Sprintf("func (x *%s) EncodeTo(enc *%sEncoder) {\n", typeName, protoPrefix))
	// cmd
	if index := bytes.LastIndex([]byte(typeName), []byte("Command")); index > 0 {
		b.WriteString(fmt.Sprintf("\tx.Cmd = uint8(Cmd%s)\n\n", typeName[0:index]))
	}
	if index := bytes.LastIndex([]byte(typeName), []byte("Reply")); index > 0 {
		b.WriteString("\tx.Cmd = uint8(CmdReply)\n\n")
	}
	// fields
	for _, field := range structType.Fields.List {
		switch typ := field.Type.(type) {
		case *ast.Ident:
			if len(field.Names) == 0 {
				break
			}

			if _, ok := typeMap[typ.Name]; ok {
				b.WriteString(fmt.Sprintf("\tenc.Encode%s(x.%s)\n", strings.Title(typ.Name), field.Names[0].Name))
			} else {
				b.WriteString(fmt.Sprintf("\tx.%s.EncodeTo(enc)\n", field.Names[0].Name))
			}
		case *ast.ArrayType:
			identType, ok := typ.Elt.(*ast.Ident)
			if !ok {
				break
			}
			if identType.Name == "byte" {
				b.WriteString(fmt.Sprintf("\tenc.EncodeBytes(x.%s[:])\n", field.Names[0].Name))
			}
		}
	}
	b.WriteString("}\n\n")
}

func generateDecodeFrom(typeSpec *ast.TypeSpec, structType *ast.StructType, b *strings.Builder) {
	b.WriteString("// DecodeFrom\n")
	typeName := typeSpec.Name.Name
	b.WriteString(fmt.Sprintf("func (x *%s) DecodeFrom(dec *%sDecoder) error {\n", typeName, protoPrefix))
	// cmd
	if index := bytes.LastIndex([]byte(typeName), []byte("Command")); index > 0 {
		b.WriteString(fmt.Sprintf("\tx.Cmd = uint8(Cmd%s)\n\n", typeName[0:index]))
	}
	if index := bytes.LastIndex([]byte(typeName), []byte("Reply")); index > 0 {
		b.WriteString("\tx.Cmd = uint8(CmdReply)\n")
	}
	hasErrDecl := false
	// fields
	for _, field := range structType.Fields.List {
		switch typ := field.Type.(type) {
		case *ast.Ident:
			if len(field.Names) == 0 {
				break
			}

			if _, ok := typeMap[typ.Name]; ok {
				if typ.Name != "string" {
					if !hasErrDecl {
						b.WriteString("\t\nvar err error\n")
						hasErrDecl = true
					}
					b.WriteString(fmt.Sprintf(`
	if x.%s, err = dec.Decode%s(); err != nil {
		return err
	}`, field.Names[0].Name, strings.Title(typ.Name)))
				} else {
					if field.Tag != nil {
						tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
						protoVal := strings.Split(tag.Get("proto"), ":")
						if len(protoVal) == 2 && protoVal[0] == "len" {
							if !hasErrDecl {
								b.WriteString("\t\nvar err error\n")
								hasErrDecl = true
							}
							b.WriteString(fmt.Sprintf(`
	{
		buf := make([]byte, x.%s)
		if err = dec.DecodeBytes(buf); err != nil {
			return err
		}
		x.%s = string(buf)
	}`, protoVal[1], field.Names[0].Name))
						}
					} else {
						b.WriteString(fmt.Sprintf("\n\tx.%s = string(dec.Bytes())\n", field.Names[0].Name))
					}
				}
			} else {
				if !hasErrDecl {
					b.WriteString("\t\nvar err error\n")
					hasErrDecl = true
				}
				b.WriteString(fmt.Sprintf(`
	if err = x.%s.DecodeFrom(dec); err != nil {
		return err
	}`, field.Names[0].Name))
			}
		case *ast.ArrayType:
			identType, ok := typ.Elt.(*ast.Ident)
			if !ok {
				break
			}
			if identType.Name == "byte" {
				if typ.Len != nil {
					if !hasErrDecl {
						b.WriteString("\n\tvar err error\n")
						hasErrDecl = true
					}
					b.WriteString(fmt.Sprintf(`
	if err = dec.DecodeBytes(x.%s[:]); err != nil {
		return err
	}`, field.Names[0].Name))
				} else {
					if field.Tag == nil {
						b.WriteString(fmt.Sprintf("\n\tx.%s = dec.Bytes()\n", field.Names[0].Name))
					} else {
						tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
						protoVal := strings.Split(tag.Get("proto"), ":")
						if len(protoVal) == 2 && protoVal[0] == "len" {
							if !hasErrDecl {
								b.WriteString("\n\tvar err error\n")
								hasErrDecl = true
							}
							b.WriteString(fmt.Sprintf(`
	x.%s = make([]byte, x.%s)
	if err = dec.DecodeBytes(x.%s); err != nil {
		return err
	}`, field.Names[0].Name, protoVal[1], field.Names[0].Name))
						}
					}
				}
			}
		}
	}
	b.WriteString("\n\n\treturn nil\n}\n")
}
