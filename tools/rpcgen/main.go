package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"path"
	"reflect"
	"strings"
)

var typeMap = map[string]bool{
	"byte":   true,
	"bool":   true,
	"int8":   true,
	"int16":  true,
	"int32":  true,
	"int64":  true,
	"uint8":  true,
	"uint16": true,
	"uint32": true,
	"uint64": true,
	"string": true,
}

var (
	input string
	rpc   bool

	protoPrefix string
)

func main() {
	flag.StringVar(&input, "input", "", "input file")
	flag.BoolVar(&rpc, "rpc", false, "rpc")
	flag.Parse()

	if _, err := ioutil.ReadFile(input); err != nil {
		log.Fatal(err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, input, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	output := strings.TrimSuffix(input, ".go") + ".proto.go"
	generateProtoFile(fset, f, output)

	if rpc {
		output := strings.TrimSuffix(input, ".go") + "_rpc.proto.go"
		generateRPCProtoFile(fset, f, output)
	}
}

func generateProtoFile(fset *token.FileSet, f *ast.File, output string) {
	var b strings.Builder

	// package
	b.WriteString("// Code generated by speedfs-gen. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n\n", f.Name))

	if path.Dir(input) != "proto" {
		b.WriteString("import (\n\t\"github.com/speedfs/speedfs/proto\"\n)\n\n")
		protoPrefix = "proto."
	}

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if !token.IsExported(typeSpec.Name.Name) {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			generateEncodeTo(typeSpec, structType, &b)
			generateDecodeFrom(typeSpec, structType, &b)
			generateCmd(typeSpec, structType, &b)
		}
	}

	buf, err := format.Source([]byte(b.String()))
	if err != nil {
		fmt.Println(b.String())
		log.Fatal(err)
	}

	w, err := os.OpenFile(output, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0755)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := w.Write(buf); err != nil {
		log.Fatal(err)
	}
}

func generateEncodeTo(typeSpec *ast.TypeSpec, structType *ast.StructType, b *strings.Builder) {
	b.WriteString("// EncodeTo\n")
	typeName := typeSpec.Name.Name
	b.WriteString(fmt.Sprintf("func (x *%s) EncodeTo(enc *%sEncoder) {\n", typeName, protoPrefix))

	// fields
	for _, field := range structType.Fields.List {
		switch typ := field.Type.(type) {
		case *ast.Ident:
			if len(field.Names) == 0 {
				break
			}

			if _, ok := typeMap[typ.Name]; ok {
				b.WriteString(fmt.Sprintf("\tenc.Encode%s(x.%s)\n", strings.Title(typ.Name), field.Names[0].Name))
			} else {
				b.WriteString(fmt.Sprintf("\tx.%s.EncodeTo(enc)\n", field.Names[0].Name))
			}
		case *ast.ArrayType:
			identType, ok := typ.Elt.(*ast.Ident)
			if !ok {
				break
			}
			if identType.Name == "byte" {
				b.WriteString(fmt.Sprintf("\tenc.EncodeBytes(x.%s[:])\n", field.Names[0].Name))
			}
		}
	}
	b.WriteString("}\n\n")
}

func generateDecodeFrom(typeSpec *ast.TypeSpec, structType *ast.StructType, b *strings.Builder) {
	b.WriteString("// DecodeFrom\n")
	typeName := typeSpec.Name.Name
	b.WriteString(fmt.Sprintf("func (x *%s) DecodeFrom(dec *%sDecoder) error {\n", typeName, protoPrefix))

	hasErrDecl := false
	// fields
	for _, field := range structType.Fields.List {
		switch typ := field.Type.(type) {
		case *ast.Ident:
			if len(field.Names) == 0 {
				break
			}

			if _, ok := typeMap[typ.Name]; ok {
				if typ.Name != "string" {
					if !hasErrDecl {
						b.WriteString("\t\nvar err error\n")
						hasErrDecl = true
					}
					b.WriteString(fmt.Sprintf(`
	if x.%s, err = dec.Decode%s(); err != nil {
		return err
	}`, field.Names[0].Name, strings.Title(typ.Name)))
				} else {
					if field.Tag != nil {
						tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
						protoVal := strings.Split(tag.Get("proto"), ":")
						if len(protoVal) == 2 && protoVal[0] == "len" {
							if !hasErrDecl {
								b.WriteString("\t\nvar err error\n")
								hasErrDecl = true
							}
							b.WriteString(fmt.Sprintf(`
	{
		buf := make([]byte, x.%s)
		if err = dec.DecodeBytes(buf); err != nil {
			return err
		}
		x.%s = string(buf)
	}`, protoVal[1], field.Names[0].Name))
						}
					} else {
						b.WriteString(fmt.Sprintf("\n\tx.%s = string(dec.Bytes())\n", field.Names[0].Name))
					}
				}
			} else {
				if !hasErrDecl {
					b.WriteString("\t\nvar err error\n")
					hasErrDecl = true
				}
				b.WriteString(fmt.Sprintf(`
	if err = x.%s.DecodeFrom(dec); err != nil {
		return err
	}`, field.Names[0].Name))
			}
		case *ast.ArrayType:
			identType, ok := typ.Elt.(*ast.Ident)
			if !ok {
				break
			}
			if identType.Name == "byte" {
				if typ.Len != nil {
					if !hasErrDecl {
						b.WriteString("\n\tvar err error\n")
						hasErrDecl = true
					}
					b.WriteString(fmt.Sprintf(`
	if err = dec.DecodeBytes(x.%s[:]); err != nil {
		return err
	}`, field.Names[0].Name))
				} else {
					if field.Tag == nil {
						b.WriteString(fmt.Sprintf("\n\tx.%s = dec.Bytes()\n", field.Names[0].Name))
					} else {
						tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
						protoVal := strings.Split(tag.Get("proto"), ":")
						if len(protoVal) == 2 && protoVal[0] == "len" {
							if !hasErrDecl {
								b.WriteString("\n\tvar err error\n")
								hasErrDecl = true
							}
							b.WriteString(fmt.Sprintf(`
	x.%s = make([]byte, x.%s)
	if err = dec.DecodeBytes(x.%s); err != nil {
		return err
	}`, field.Names[0].Name, protoVal[1], field.Names[0].Name))
						}
					}
				}
			}
		}
	}
	b.WriteString("\n\n\treturn nil\n}\n")
}

const cmdTpl = `
// Cmd
func (x *%s) Cmd() %sCmd {
	return Cmd%s
}
`

func generateCmd(typeSpec *ast.TypeSpec, structType *ast.StructType, b *strings.Builder) {
	typeName := typeSpec.Name.Name
	// cmd
	if index := bytes.LastIndex([]byte(typeName), []byte("Command")); index > 0 {
		b.WriteString(fmt.Sprintf(cmdTpl, typeName, protoPrefix, typeName[0:index]))
	} else if index := bytes.LastIndex([]byte(typeName), []byte("Reply")); index > 0 {
		b.WriteString(fmt.Sprintf(cmdTpl, typeName, protoPrefix, "Reply"))
	}
}

const handlerTpl = `
type method func(ctx context.Context, buf []byte) (proto.Message, error)

type handler struct {
	methods [256]method
	service *service
}

func NewHandler(service %s) proto.Handler {
	h := &handler{
		service: newService(service),
	}
	h.initMethods()
	return h
}

func (h *handler) Handle(ctx context.Context, cmd uint8, buf []byte) (proto.Message, error) {
	method := h.methods[cmd]
	if method == nil {
		return nil, syscall.EINVAL
	}
	return method(ctx, buf)
}
`

const serviceTpl = `
type service struct {
	s %s
}

func newService(s %s) *service {
	return &service{
		s: s,
	}
}
`

const methodTpl = `
func (s *service) %s(ctx context.Context, buf []byte) (proto.Message, error) {
	cmd := new(%sCommand)
	dec := proto.NewDecoder(buf)

	if err := cmd.DecodeFrom(dec); err != nil {
		return nil, err
	}

	return  s.s.%s(ctx, cmd)
}
`

const connTpl = `
type Conn struct {
	*proto.Conn
}

func NewConn(conn net.Conn) *Conn {
	return &Conn{
		Conn: proto.NewConn(conn),
	}
}

`

const connMethodTpl = `
func (c *Conn) %s(ctx context.Context, cmd *%sCommand)(*%sReply, error) {
	reply := new(%sReply)
	if err := c.Call(ctx, cmd, reply); err != nil {
		return nil, err
	}
	return reply, nil
}
`

func generateRPCProtoFile(fset *token.FileSet, f *ast.File, output string) {
	var b strings.Builder

	// package
	b.WriteString("// Code generated by speedfs-gen. DO NOT EDIT.\n\n")
	b.WriteString(fmt.Sprintf("package %s\n", f.Name))

	if path.Dir(input) != "proto" {
		b.WriteString(`
import (
	"context"
	"net"
	"syscall"

	"github.com/speedfs/speedfs/proto"
)
		`)
		protoPrefix = "proto."
	}

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if !token.IsExported(typeSpec.Name.Name) {
				continue
			}
			interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}

			b.WriteString(fmt.Sprintf(handlerTpl, typeSpec.Name.Name))
			generateHandlerInitMethods(fset, typeSpec, interfaceType, &b)
			b.WriteString(fmt.Sprintf(serviceTpl, typeSpec.Name.Name, typeSpec.Name.Name))
			generateServiceMethods(fset, typeSpec, interfaceType, &b)
			b.WriteString(connTpl)
			generateConnMethods(fset, typeSpec, interfaceType, &b)
		}
	}

	buf, err := format.Source([]byte(b.String()))
	if err != nil {
		fmt.Println(b.String())
		log.Fatal(err)
	}

	w, err := os.OpenFile(output, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0755)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := w.Write(buf); err != nil {
		log.Fatal(err)
	}
}

func generateHandlerInitMethods(fset *token.FileSet, typeSpec *ast.TypeSpec, interfaceType *ast.InterfaceType, b *strings.Builder) {
	b.WriteString(`
func (h *handler) initMethods() {
`)
	for _, method := range interfaceType.Methods.List {
		switch method.Type.(type) {
		case *ast.FuncType:
			if len(method.Names) == 0 {
				break
			}

			name := method.Names[0]
			b.WriteString(fmt.Sprintf("\th.methods[Cmd%s] = h.service.%s\n", name, name))
		}
	}
	b.WriteString("}\n\n")
}

func generateServiceMethods(fset *token.FileSet, typeSpec *ast.TypeSpec, interfaceType *ast.InterfaceType, b *strings.Builder) {
	for _, method := range interfaceType.Methods.List {
		switch method.Type.(type) {
		case *ast.FuncType:
			if len(method.Names) == 0 {
				break
			}

			name := method.Names[0]
			b.WriteString(fmt.Sprintf(methodTpl, name, name, name))
		}
	}
}

func generateConnMethods(fset *token.FileSet, typeSpec *ast.TypeSpec, interfaceType *ast.InterfaceType, b *strings.Builder) {
	for _, method := range interfaceType.Methods.List {
		switch method.Type.(type) {
		case *ast.FuncType:
			if len(method.Names) == 0 {
				break
			}

			name := method.Names[0]
			b.WriteString(fmt.Sprintf(connMethodTpl, name, name, name, name))
		}
	}
}
